<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#00000000">
    <title>tangcamly</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            
        }
        . {
            color: #00000000;
        }
    </style>

    <script type="importmap">
         {
        "imports": {
          "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
        }}
    </script>
</head>

<body>
    <!-- Nh·∫°c t·ª± ƒë·ªông ph√°t -->
    <audio id="bgMusic" autoplay loop>
        <source src="songs/eyenoselip.mp3" type="audio/mpeg" />
    </audio>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            50,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, -20, 130);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 50;      // Gi·ªõi h·∫°n kh√¥ng nh√¨n qu√° g·∫ßn
        controls.maxDistance = 200;     // Gi·ªõi h·∫°n kh√¥ng nh√¨n qu√° xa
        controls.minPolarAngle = Math.PI / 4;     // Gi·ªõi h·∫°n kh√¥ng nh√¨n qu√° th·∫•p (45¬∞ t·ª´ tr√™n xu·ªëng)
        controls.maxPolarAngle = Math.PI * 0.75;  // Gi·ªõi h·∫°n kh√¥ng nh√¨n qu√° cao (135¬∞ t·ª´ d∆∞·ªõi l√™n)
        controls.minAzimuthAngle = -Math.PI / 0;  // Gi·ªõi h·∫°n xoay tr√°i t·ªëi ƒëa: -45¬∞
        controls.maxAzimuthAngle = Math.PI / 0;   // Gi·ªõi h·∫°n xoay ph·∫£i t·ªëi ƒëa: +45¬∞

        // √Ånh s√°ng n·ªÅn m·ªÅm m·∫°i
        const ambientLight = new THREE.AmbientLight(0xffaaff, 0.3);
        scene.add(ambientLight);

        // √Ånh s√°ng h∆∞·ªõng t·∫°o chi·ªÅu s√¢u
        const directionalLight = new THREE.DirectionalLight(0xff77cc, 1);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);

        // Background gradient shader
    //     const vertexShader = `
    //     varying vec2 vUv;
    //     void main() {
    //       vUv = uv;
    //       gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    //     }
    //   `;
    //     const fragmentShader = `
    //     varying vec2 vUv;
    //     void main() {
    //       vec3 topColor = vec3(0.1, 0.0, 0.2);
    //       vec3 bottomColor = vec3(0.05, 0.0, 0.1);
    //       vec3 color = mix(bottomColor, topColor, vUv.y);
    //       gl_FragColor = vec4(color, 100.0);
    //     }
    //   `;
    //     const bgMaterial = new THREE.ShaderMaterial({
    //         vertexShader,
    //         fragmentShader,
    //         side: THREE.DoubleSide,
    //         depthWrite: false,
    //     });
    //     const bgPlane = new THREE.Mesh(
    //         new THREE.PlaneGeometry(500, 500),
    //         bgMaterial
    //     );
    //     bgPlane.position.z = -100;
    //     scene.add(bgPlane);

        // Sao tr·ªùi v·ªõi shader nh·∫•p nh√°y m·ªÅm m·∫°i
        const starCount = 5000;
        const starPositions = new Float32Array(starCount * 3);
        const starOpacities = new Float32Array(starCount);
        // Ph√¢n b·ªë sao ƒë·ªÅu kh·∫Øp kh√¥ng gian (x: -200‚Üí200, y: -200‚Üí200, z: -200‚Üí200)
        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 400;        // x
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 400;    // y (ƒë√£ s·ª≠a)
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 400;    // z
            starOpacities[i] = Math.random();
        }


        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute(
            "position",
            new THREE.BufferAttribute(starPositions, 3)
        );
        starGeometry.setAttribute(
            "opacity",
            new THREE.BufferAttribute(starOpacities, 1)
        );

        const starVertexShader = `
        attribute float opacity;
        varying float vOpacity;
        void main() {
          vOpacity = opacity;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = 2.0 * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `;
        const starFragmentShader = `
        varying float vOpacity;
        uniform float time;
        void main() {
          float alpha = 0.5 + 0.5 * sin(time + vOpacity * 6.2831);
          vec2 coords = gl_PointCoord - vec2(0.5);
          float dist = length(coords);
          if (dist > 0.5) discard;
          gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * (1.0 - dist * 2.0));
        }
      `;
        const starUniforms = {
            time: { value: 0 },
        };
        const starMaterial = new THREE.ShaderMaterial({
            vertexShader: starVertexShader,
            fragmentShader: starFragmentShader,
            transparent: true,
            uniforms: starUniforms,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Glow material cho sprite
        function createGlowMaterial(texture) {
            return new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
        }

        // T·∫°o sprite ch·ªØ c√≥ glow
        function createTextSprite(text) {
            const scaleFactor = 4;
            const fontSize = 25 * scaleFactor;
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            ctx.font = `${fontSize}px sans-serif`;
            const textWidth = ctx.measureText(text).width;
            canvas.width = textWidth + 25 * scaleFactor;
            canvas.height = fontSize + 25 * scaleFactor;
            ctx.font = `${fontSize}px sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            ctx.shadowColor = "rgba(255, 160, 180, 0.7)";
            ctx.shadowBlur = 20;
            ctx.fillStyle = "#e5f0f0";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const material = createGlowMaterial(texture);
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(
                canvas.width / (10 * scaleFactor),
                canvas.height / (10 * scaleFactor),
                1
            );
            sprite.position.set(
                (Math.random() - 0.5) * 100,
                Math.random() * 60 + 30,
                (Math.random() - 0.5) * 20
            );
            sprite.rotation.z = THREE.MathUtils.degToRad(15);
            return sprite;
        }

        const texts = [
            "Anh nh·ªõ nhi·ªÅu em",
            "M√£i b√™n nhau em nh√©",
            "Lu√¥n h·∫°nh ph√∫c",
            "T√¨nh y√™u n√†y ch·ªâ d√†nh cho em",
            "Tr√°i tim n√†y ch·ªâ c√≥ m√¨nh em th√¥i",
            "M·ªói ng√†y b√™n em l√† 1 m√≥n qu√†",
            "Em l√† t·∫•t c·∫£ c·ªßa anh",
            "Y√™u em nh·∫•t tr√™n ƒë·ªùi",
            "C·∫£m ∆°n em ƒë√£ ƒë·∫øn b√™n anh",
            "Th·∫ø gi·ªõi c·ªßa anh l√† em",
        ];
        const textSprites = texts.map((t) => {
            const s = createTextSprite(t);
            scene.add(s);
            return s;
        });

        // T·∫°o texture tr√°i tim
        function createHeartTexture(emoji) {
            const size = 64;
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext("2d");
            // S·ª≠ d·ª•ng font h·ªá th·ªëng h·ªó tr·ª£ emoji t·ªët h∆°n
            ctx.font = "48px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = "rgba(255, 105, 180, 0.5)";
            ctx.shadowBlur = 15;
            ctx.fillStyle = "rgba(255, 0, 85, 0.9)";
            ctx.fillText(emoji, size / 2, size / 2 + 2); // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ Y m·ªôt ch√∫t cho c√¢n ƒë·ªëi
            return new THREE.CanvasTexture(canvas);
        }

        const heartEmojis = ["‚ù§Ô∏è", "üíï", "üíì", "üíó", "üíñ", "üíù"];
        const heartTextures = heartEmojis.map(createHeartTexture);

        const hearts = [];
        for (let i = 0; i < 50; i++) {
            const randomTexture = heartTextures[Math.floor(Math.random() * heartTextures.length)];
            const h = new THREE.Sprite(createGlowMaterial(randomTexture));
            h.scale.set(2.5, 2.5, 1);
            h.position.set(
                (Math.random() - 0.5) * 100,
                Math.random() * 60 + 30,
                (Math.random() - 0.5) * 20
            );
            scene.add(h);
            hearts.push(h);
        }

        // H√†m "CSS-in-JS" ƒë·ªÉ t·∫°o ·∫£nh tr√≤n c√≥ vi·ªÅn h·ªìng
        function createStyledImageTexture(image) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // T·∫°o canvas vu√¥ng d·ª±a tr√™n k√≠ch th∆∞·ªõc l·ªõn nh·∫•t c·ªßa ·∫£nh
            const size = Math.max(image.width, image.height);

            // Th√™m kho·∫£ng ƒë·ªám ƒë·ªÉ hi·ªáu ·ª©ng glow c√≥ kh√¥ng gian hi·ªÉn th·ªã
            const padding = size * 0.15; // 15% padding
            canvas.width = size + padding * 2;
            canvas.height = size + padding * 2;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // T·ªça ƒë·ªô v√† k√≠ch th∆∞·ªõc c·ªßa v√πng ·∫£nh b√™n trong canvas
            const rectX = centerX - image.width / 2;
            const rectY = centerY - image.height / 2;
            const rectWidth = image.width;
            const rectHeight = image.height;
            // ƒê√¢y l√† gi√° tr·ªã bo g√≥c, t∆∞∆°ng ƒë∆∞∆°ng "border-radius".
            // B·∫°n c√≥ th·ªÉ thay ƒë·ªïi s·ªë 25 ƒë·ªÉ bo g√≥c nhi·ªÅu h∆°n ho·∫∑c √≠t h∆°n.
            const borderRadius = 25;

            // B·∫Øt ƒë·∫ßu v·∫Ω h√¨nh ch·ªØ nh·∫≠t bo g√≥c
            ctx.beginPath();
            ctx.moveTo(rectX + borderRadius, rectY);
            ctx.lineTo(rectX + rectWidth - borderRadius, rectY);
            ctx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + borderRadius);
            ctx.lineTo(rectX + rectWidth, rectY + rectHeight - borderRadius);
            ctx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - borderRadius, rectY + rectHeight);
            ctx.lineTo(rectX + borderRadius, rectY + rectHeight);
            ctx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - borderRadius);
            ctx.lineTo(rectX, rectY + borderRadius);
            ctx.quadraticCurveTo(rectX, rectY, rectX + borderRadius, rectY);
            ctx.closePath();

            // 1. V·∫Ω vi·ªÅn h·ªìng ph√°t s√°ng (gi·ªëng tr√°i tim)
            ctx.shadowColor = "rgba(255, 105, 180, 0.7)";
            ctx.shadowBlur = 30;
            ctx.strokeStyle = "rgba(255, 105, 180, 0.9)";
            ctx.lineWidth = size * 0.05; // ƒê·ªô d√†y vi·ªÅn b·∫±ng 5% k√≠ch th∆∞·ªõc ·∫£nh
            ctx.stroke();

            // T·∫Øt hi·ªáu ·ª©ng shadow ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn ·∫£nh g·ªëc
            ctx.shadowColor = 'transparent';

            // 2. T·∫°o v√πng c·∫Øt (clip) theo h√¨nh ƒë√£ v·∫Ω ƒë·ªÉ l√†m bo g√≥c
            ctx.clip();

            // 3. V·∫Ω ·∫£nh v√†o b√™n trong v√πng ƒë√£ c·∫Øt
            ctx.drawImage(image, rectX, rectY);

            return new THREE.CanvasTexture(canvas);
        }

        // Th√™m c√°c URL h√¨nh ·∫£nh c·ªßa b·∫°n v√†o ƒë√¢y
        const imageUrls = [
            "image/a01.jpeg",
            "image/a02.jpg",
            "image/a03.jpg",
            "image/a04.jpg",
        ];
        const textureLoader = new THREE.TextureLoader();
        const imageSprites = [];
        const imageDatas = []; // L∆∞u tr·ªØ texture v√† t·ª∑ l·ªá khung h√¨nh

        // H√†m t·∫°o sprite ·∫£nh v·ªõi t·ª∑ l·ªá khung h√¨nh ch√≠nh x√°c
        function createImageSprite(texture, aspectRatio) {
            const imageMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(imageMaterial);
            
            const spriteHeight = 10; // ƒê·∫∑t chi·ªÅu cao c·ªë ƒë·ªãnh cho ·∫£nh
            const spriteWidth = spriteHeight * aspectRatio; // T√≠nh chi·ªÅu r·ªông d·ª±a tr√™n t·ª∑ l·ªá
            sprite.scale.set(spriteWidth, spriteHeight, 1);
            
            return sprite;
        }

        // H√†m t·∫°o c√°c sprite ·∫£nh ban ƒë·∫ßu
        function createInitialImageSprites() {
            if (imageDatas.length === 0) return;
            for (let i = 0; i < 5; i++) {
                const randomData = imageDatas[Math.floor(Math.random() * imageDatas.length)];
                const sprite = createImageSprite(randomData.texture, randomData.aspectRatio);
                sprite.position.set(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 60 + 30,
                    (Math.random() - 0.5) * 20
                );
                scene.add(sprite);
                imageSprites.push(sprite);
            }
        }

        // T·∫£i tr∆∞·ªõc t·∫•t c·∫£ ·∫£nh. Khi t·∫•t c·∫£ ƒë√£ t·∫£i xong, m·ªõi t·∫°o c√°c ·∫£nh ban ƒë·∫ßu.
        let loadedImageCount = 0;
        imageUrls.forEach(url => textureLoader.load(url, (loadedTexture) => {
            const styledTexture = createStyledImageTexture(loadedTexture.image);
            // V√¨ canvas gi·ªù l√† h√¨nh vu√¥ng, t·ª∑ l·ªá khung h√¨nh lu√¥n l√† 1
            imageDatas.push({ texture: styledTexture, aspectRatio: 1 });
            loadedImageCount++;
            if (loadedImageCount === imageUrls.length) {
                createInitialImageSprites();
            }
        }));

        window.addEventListener("click", () => {
            const rand = Math.random();
            // T·ªâ l·ªá: 45% tr√°i tim, 45% ch·ªØ, 10% h√¨nh ·∫£nh
            if (rand < 0.45) { // Th·∫£ tr√°i tim
                const randomTexture = heartTextures[Math.floor(Math.random() * heartTextures.length)];
                const h = new THREE.Sprite(createGlowMaterial(randomTexture));
                h.scale.set(2.5, 2.5, 1);
                h.position.set(
                    (Math.random() - 0.5) * 100,
                    50,
                    (Math.random() - 0.5) * 20
                );
                scene.add(h);
                hearts.push(h);
            } else if (rand < 0.90) { // Th·∫£ ch·ªØ
                const randomText = texts[Math.floor(Math.random() * texts.length)];
                const s = createTextSprite(randomText);
                scene.add(s);
                textSprites.push(s);
            } else { // Th·∫£ h√¨nh ·∫£nh
                if (imageDatas.length === 0) return; // B·ªè qua n·∫øu ·∫£nh ch∆∞a t·∫£i xong

                const randomData = imageDatas[Math.floor(Math.random() * imageDatas.length)];
                const s = createImageSprite(randomData.texture, randomData.aspectRatio);

                s.position.set(
                    (Math.random() - 0.5) * 100,
                    50,
                    (Math.random() - 0.5) * 20
                );
                scene.add(s);
                imageSprites.push(s);
            }
        });

        function animate(time = 0) {
            requestAnimationFrame(animate);
            controls.update();
            starUniforms.time.value = time / 1000;

            // Ch·ªØ r∆°i
            textSprites.forEach((s) => {
                s.position.y -= 0.25;
                if (s.position.y < -30) {
                    s.position.y = 60;
                    s.position.x = (Math.random() - 0.5) * 100;
                }
            });

            // Tr√°i tim r∆°i
            hearts.forEach((h) => {
                h.position.y -= 0.2;
                if (h.position.y < -20) {
                    h.position.y = Math.random() * 40 + 20;
                    h.position.x = (Math.random() - 0.5) * 100;
                }
            });

            // H√¨nh ·∫£nh r∆°i
            imageSprites.forEach((s) => {
                s.position.y -= 0.15; // T·ªëc ƒë·ªô r∆°i ch·∫≠m h∆°n m·ªôt ch√∫t
                if (s.position.y < -30) {
                    s.position.y = 60;
                    s.position.x = (Math.random() - 0.5) * 100;
                }
            });

            renderer.render(scene, camera);
        }



        animate();

        // X·ª≠ l√Ω nh·∫°c t·ª± ƒë·ªông ph√°t (v·∫•n ƒë·ªÅ tr√¨nh duy·ªát)
        const bgMusic = document.getElementById("bgMusic");
        bgMusic.volume = 0.5;
        bgMusic.play().catch(() => {
            console.log("Tr√¨nh duy·ªát ch·∫∑n autoplay. ƒê·ª£i t∆∞∆°ng t√°c...");
            const unlock = () => {
                bgMusic.play();
                window.removeEventListener("click", unlock);
                window.removeEventListener("touchstart", unlock);
            };
            window.addEventListener("click", unlock);
            window.addEventListener("touchstart", unlock);
        });

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>